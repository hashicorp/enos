## REUSABLE WORKFLOW: build-and-validate.yml

name: build-and-validate

on:
  workflow_call:
    outputs:
      filepath:
        description: binary filepath
        value: ${{ jobs.build.steps.outputs.filepath }}
        # ^example: ${{ steps.get-product-version.outputs.product-version }}             
                

env:
  PKG_NAME: "enos"

jobs:

  get-product-version:
    runs-on: linux
    outputs:
      product-version: ${{ steps.get-product-version.outputs.product-version }}
    steps:
      - uses: actions/checkout@v2
      - name: get product version
        id: get-product-version
        run: |
          make version
          echo "::set-output name=product-version::$(make version)"

  generate-metadata-file:
    needs: get-product-version
    runs-on: linux
    outputs:
      filepath: ${{ steps.generate-metadata-file.outputs.filepath }}
    steps:
      - name: 'Checkout directory'
        uses: actions/checkout@v2
      - name: Generate metadata file
        id: generate-metadata-file
        uses: hashicorp/actions-generate-metadata@main
        with:
          version: ${{ needs.get-product-version.outputs.product-version }}
          product: ${{ env.PKG_NAME }}

      - uses: actions/upload-artifact@v2
        with:
          name: metadata.json
          path: ${{ steps.generate-metadata-file.outputs.filepath }}

  build:
    needs: get-product-version
    runs-on: linux
    strategy:
      matrix:
        include:
          - {go: "1.17", goos: "linux", goarch: "amd64"}
          - {go: "1.17", goos: "linux", goarch: "arm64"}
          - {go: "1.17", goos: "darwin", goarch: "amd64"}
          - {go: "1.17", goos: "darwin", goarch: "arm64"}
      fail-fast: true

    name: Go ${{ matrix.go }} ${{ matrix.goos }} ${{ matrix.goarch }} build
    outputs:
      filepath: ${{ steps.get-product-version.outputs.product-version }}
    env:
      GOPRIVATE: 'github.com/hashicorp/*'
      TOKEN: ${{ secrets.ELEVATED_GITHUB_TOKEN }}

    steps:
      - uses: actions/checkout@v2

      - name: Setup go
        uses: actions/setup-go@v2
        with:
          go-version: ${{ matrix.go }}

      - name: Build
        env:
          GOOS: ${{ matrix.goos }}
          GOARCH: ${{ matrix.goarch }}
        run: |
          mkdir dist out
          make
          zip -r -j out/${{ env.PKG_NAME }}_${{ needs.get-product-version.outputs.product-version }}_${{ matrix.goos }}_${{ matrix.goarch }}.zip dist/
        # ^ take everything (-r recursive) that's in dist/ and zip it into out/[filepath].zip
        # [requires the build step to place the binary in dist/]
        # -r = --recurse-paths    All the files and directories in foo are saved in a zip archive named foo.zip
        # -j = --junk-paths       Store just  the name of a saved file (junk the path), and do not store directory names. By default, zip will store the full path (relative to the current directory)
        # ******QUESTION****** If this is saying "take everything that's in dist/ and zip it into a zip archive with this name", and the build process always
        # saves to dist/ so builds from all the matrix variants are in there, won't we have several binaries in that directory, getting zipped together?
          echo "::set-output name=filepath::out/${{ env.PKG_NAME }}_${{ needs.get-product-version.outputs.product-version }}_${{ matrix.goos }}_${{ matrix.goarch }}.zip"
        # following this pattern: echo "::set-output name=product-version::$(make version)"
        #                         echo "::set-output name=item-name::item-value"
        # *****QUESTION****
        # Is this ^ the right way to output the filepath to the binary?

    lint:
    name: "lint"
    runs-on: ubuntu-latest
    # ******QUESTION**** Shouldn't these be running on the same runner as the build steps?
    container: docker.mirror.hashicorp.services/golangci/golangci-lint:latest-alpine
    steps:
      - uses: actions/checkout@v2
      - run: golangci-lint run --out-format=github-actions --timeout=5m0s

    unit:
      name: "unit tests"
      runs-on: ubuntu-latest
      steps:
      - uses: actions/setup-go@v2
          with:
          go-version: '^1.17.2'
      - uses: actions/checkout@v2
      - run: make test

    build-and-acceptance:
      name: "build and acceptance tests"
      runs-on: ubuntu-latest
      needs: build
      steps:
      - uses: actions/checkout@v2
      - uses: actions/setup-go@v2
          with:
          go-version: '^1.17.2'
      - run: make test-acc 
      # was previously `make test-acc-release`
      # *****QUESTION***** Since `go test` builds the binary itself, we do not need to pass it the file path of the binary that was built in the `build` step, correct?
      # ${TEST_ACC} ${GORACE} ENOS_BINARY_PATH=${BUILD_BINARY_PATH} go test -race ./... -v $(TESTARGS) -timeout 120m
          env:
          CI: true
